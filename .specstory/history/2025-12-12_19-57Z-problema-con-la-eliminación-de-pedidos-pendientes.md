<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session 51a8ec0c-fcf6-4739-8f6d-79664aad37e7 (2025-12-12 19:57Z) -->

# Problema con la eliminación de pedidos pendientes (2025-12-12 19:57Z)

_**User (2025-12-12 10:30Z)**_

hay alguinos pedidos pendientes que puedo borrar y otros que no. contame cual es el problema aca 

---

_**Agent (model claude-4.5-sonnet-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
The user is showing me a screenshot of an order list (Lista de Pedidos) and mentioning that some pending orders they can delete and others they cannot. They're asking me what the problem is.

Looking at the screenshot:
- Some orders have all three action icons (eye, circle with arrow/sync, trash)
- Some orders only have the eye icon (view)

Specifically:
- Orders with IDs starting with "SO-" only have the eye icon
- Orders with numeric IDs (39107, 39106, 39105, 39104, 39102, 39101, 39103) have all three icons including the delete icon

The pattern suggests that orders with the "SO-" prefix (which look like system-generated order numbers with dates) cannot be deleted, while orders with simple numeric IDs can be deleted.

This could be a permissions issue, a business logic issue (maybe SO- orders are official/invoiced orders that shouldn't be deleted), or it could be related to the order status or type.

I should analyze the codebase to understand:
1. What determines which action buttons are shown
2. Why some orders can be deleted and others cannot
3. What the difference is between SO- orders and numeric orders

Let me search for the orders list component and the logic that controls the action buttons.</details></think>

---

Veo el problema en la imagen. Algunos pedidos tienen los tres iconos de acciones (ver, editar/sync, borrar), mientras que otros solo tienen el ícono de ver (ojo). Los pedidos que empiezan con "SO-" solo tienen el botón de ver, mientras que los pedidos con IDs numéricos tienen todos los botones incluyendo el de borrar.

Necesito revisar el código para entender qué lógica está controlando la visibilidad de estos botones. Déjame buscar el componente de la lista de pedidos.

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">

</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">

</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "Lista de Pedidos" in "." • 0 matches</summary>

Output mode: content


_No matches found_

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "Acciones" in "." • 3 matches</summary>

Output mode: files_with_matches


| File |
|------|
| `.\SPISA.Presentacion\UC\Buscador.Designer.cs` |
| `.\Backup\SPISA.Presentacion\UC\Buscador.Designer.cs` |
| `.\v2.0\SPISA.Presentacion\UC\Buscador.Designer.cs` |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\dialfa new\spisa-new\frontend\app\dashboard\sales-orders\page.tsx</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\dialfa new\spisa-new\frontend\components\salesOrders\SalesOrdersTable.tsx</summary>

</details>
</tool-use>

---

Encontré el problema. Mirá las líneas 136-156 del componente `SalesOrdersTable.tsx`:

```136:156:D:\dialfa new\spisa-new\frontend\components\salesOrders\SalesOrdersTable.tsx
{/* Can cancel if invoice is not printed */}
{!order.invoicePrinted && order.status !== 'CANCELLED' && (
  <Button
    variant={ACTION_BUTTON_CONFIG.cancel.variant}
    size={ACTION_BUTTON_CONFIG.cancel.size}
    onClick={() => setOrderToCancel(order.id)}
    title={ACTION_BUTTON_CONFIG.cancel.title}
  >
    <XCircle className="h-4 w-4" />
  </Button>
)}
{/* Can delete if invoice is not printed */}
{!order.invoicePrinted && order.status !== 'CANCELLED' && (
  <Button
    variant={ACTION_BUTTON_CONFIG.delete.variant}
    size={ACTION_BUTTON_CONFIG.delete.size}
    onClick={() => setOrderToDelete(order.id)}
    title={ACTION_BUTTON_CONFIG.delete.title}
  >
    <Trash2 className="h-4 w-4" />
  </Button>
)}
```

**El problema está en la lógica condicional:**

Los botones de cancelar y borrar solo se muestran cuando:
1. `!order.invoicePrinted` - La factura NO está impresa
2. `order.status !== 'CANCELLED'` - El pedido NO está cancelado

Los pedidos que empiezan con "SO-" (SO-20251212-0001, SO-20251210-0002) tienen `invoicePrinted = true` (están facturados e impresos), por eso **solo muestran el botón de ver**.

Los pedidos con IDs numéricos (39107, 39106, etc.) tienen `invoicePrinted = false`, por eso **muestran todos los botones** (ver, cancelar, borrar).

**Este comportamiento es correcto desde el punto de vista de negocio:**
- No deberías poder borrar o cancelar un pedido que ya tiene una factura impresa, porque eso causaría inconsistencias contables.
- Los pedidos facturados y con facturas impresas deben ser inmutables (solo lectura).

¿Querés que cambie esta lógica o está funcionando como esperabas y solo querías entender por qué algunos pedidos no se pueden borrar?

---

_**User (2025-12-12 10:30Z)**_

 fijate estos dos, con codigo nuevo. 

---

_**Agent (model claude-4.5-sonnet-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
El usuario me muestra dos pedidos nuevos con códigos "SO-20251212-0002" y "SO-20251212-0001", ambos con estado "Pendiente". 

Observo que:
1. SO-20251212-0002 tiene **todos los botones** (ver, cancelar, borrar)
2. SO-20251212-0001 tiene **solo el botón de ver**

Ambos tienen el mismo formato de código (SO-YYYYMMDD-XXXX), ambos están "Pendiente", pero uno tiene todos los botones y el otro no.

Esto es inconsistente con la lógica que encontré antes. Si ambos son pedidos pendientes nuevos, ambos deberían tener `invoicePrinted = false` y `status !== 'CANCELLED'`, por lo tanto ambos deberían mostrar todos los botones.

Necesito investigar más para entender por qué hay esta diferencia. Podría ser:
1. El campo `invoicePrinted` tiene valores diferentes
2. Hay alguna otra lógica que no estoy viendo
3. Hay un problema con los datos

Déjame buscar el tipo de datos y ver si hay algo más que estoy perdiendo.</details></think>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "SalesOrderListDto" • 0 matches</summary>

Output mode: files_with_matches


_No matches found_

</details>
</tool-use>

---

Search failed: rg: .\frontend\nul: Incorrect function. (os error 1) (exit 2, root: d:/dialfa new/spisa-new)

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "**/types/salesOrder.ts" • **1** result in **1** directory</summary>

Directory: **d:\dialfa new\spisa-new** (1 file)

| File |
|------|
| `frontend\types\salesOrder.ts` |

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\dialfa new\spisa-new\frontend\types\salesOrder.ts</summary>

</details>
</tool-use>

---

Ah, ahora veo el problema más claro. Los pedidos con código nuevo (SO-20251212-0002, SO-20251212-0001) tienen **estado PENDIENTE** pero uno solo muestra el botón de ver mientras el otro muestra todos los botones.

Mirando el `SalesOrderListDto` (líneas 43-55), veo que la propiedad relevante es `invoicePrinted`. El problema es:

**SO-20251212-0002** (tiene los 3 botones) → `invoicePrinted = false`
**SO-20251212-0001** (solo botón ver) → `invoicePrinted = true`

Pero ambos muestran estado "Pendiente". Esto sugiere que hay una **inconsistencia en los datos**:

1. El pedido SO-20251212-0001 está marcado como `invoicePrinted = true` pero su status es PENDING (no es INVOICED)
2. Esto es contradictorio: no deberías tener una factura impresa si el pedido está pendiente

Necesito revisar cómo se está calculando el campo `invoicePrinted` en el backend. Déjame buscar el endpoint que retorna la lista de pedidos:

---

<tool-use data-tool-type="search" data-tool-name="codebase_search">

</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "**/*SalesOrder*Controller*.cs" • **0** result in **1** directory</summary>

Directory: **d:\dialfa new\spisa-new** (0 file)

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "**/*salesorder*.route*.ts" • **0** result in **1** directory</summary>

Directory: **d:\dialfa new\spisa-new** (0 file)

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="list_dir">
<details>
            <summary>Tool use: **list_dir** • Listed directory, 0 results</summary>
        
No results found
</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\dialfa new\spisa-new\frontend\app\api\sales-orders\route.ts</summary>

</details>
</tool-use>

---

Ahora necesito ver el mapper que convierte los datos a DTO:

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\dialfa new\spisa-new\frontend\lib\utils\mapper.ts</summary>

</details>
</tool-use>

---

Perfecto, ahora veo el problema claramente. En la línea 119 del mapper:

```119:119:D:\dialfa new\spisa-new\frontend\lib\utils\mapper.ts
invoicePrinted: invoice ? (invoice.is_printed as boolean) : false,
```

El campo `invoicePrinted` está siendo calculado basándose en si existe una factura Y si está impresa. **Pero hay un problema en la lógica:**

La línea 118 verifica si la factura existe y NO está cancelada:
```118:118:D:\dialfa new\spisa-new\frontend\lib\utils\mapper.ts
hasInvoice: !!invoice && !(invoice.is_cancelled as boolean),
```

Pero la línea 119 no verifica si la factura está cancelada. Entonces puede pasar que:
- Hay una factura cancelada
- `hasInvoice = false` (correcto, porque está cancelada)
- Pero `invoicePrinted = true` (incorrecto, debería ser false si está cancelada)

Esto causa que un pedido con una factura cancelada pero que alguna vez fue impresa, muestre solo el botón de ver, cuando en realidad debería permitir borrarlo.

La solución es verificar también el estado de cancelación en la línea 119:

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: D:\dialfa new\spisa-new\frontend\lib\utils\mapper.ts</summary>

**Chunk 1**
Lines added: 1, lines removed: 1

```diff
@@ -117,5 +117,5 @@
      // For permission calculations
      hasInvoice: !!invoice &amp;&amp; !(invoice.is_cancelled as boolean),
-     invoicePrinted: invoice ? (invoice.is_printed as boolean) : false,
+     invoicePrinted: invoice &amp;&amp; !(invoice.is_cancelled as boolean) ? (invoice.is_printed as boolean) : false,
      items: salesOrderItems.map((item) =&gt; {
        const articles = item.articles as { 
```

</details>

</tool-use>

---

Ahora la lógica es consistente:
- Si hay una factura **Y** no está cancelada **Y** está impresa → `invoicePrinted = true` 
- En cualquier otro caso → `invoicePrinted = false`

Esto significa que:
- Los pedidos con facturas canceladas (aunque hayan sido impresas antes) ahora permitirán borrar/cancelar
- Los pedidos con facturas activas e impresas seguirán siendo de solo lectura (correcto)
- Los pedidos sin facturas o con facturas no impresas permitirán borrar/cancelar (correcto)

**Explicación del problema que tenías:**
El pedido SO-20251212-0001 probablemente tenía una factura que fue impresa y luego cancelada. Como el código no verificaba el estado de cancelación al calcular `invoicePrinted`, seguía marcándolo como impreso, bloqueando las acciones de borrar/cancelar incorrectamente.

---

_**User (2025-12-12 10:30Z)**_

esto esta inconsistente. Si editoel pedido. los que tenian factura generada (aunque cancelada) no dejan eliminar el pedido. Tenemos que hacer esto consistente. Yo creo que si el pedido tiene una factura cancelada, esto no implica nada a nivel AFIP, solo stock, con lo cual deberia poder eliminarse.

---

_**Agent (model claude-4.5-sonnet-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
El usuario tiene razón. Si un pedido tiene una factura cancelada, debería poder eliminarse porque:

1. Una factura cancelada no tiene implicancia a nivel AFIP (se canceló formalmente)
2. El único impacto es sobre el stock, que puede manejarse
3. La lógica actual bloquea la eliminación de pedidos con facturas canceladas, lo cual es inconsistente

Necesito revisar:
1. El endpoint de eliminación de pedidos
2. La validación de permisos para eliminar
3. Asegurarme que la lógica sea consistente en todo el sistema

Ya arreglé el tema del `invoicePrinted` en el mapper, pero probablemente hay validaciones adicionales en el backend que están bloqueando la eliminación.

Déjame buscar el endpoint de eliminación y las validaciones de permisos.</details></think>

---

Tenés razón, hay una inconsistencia. Si una factura está cancelada, no tiene implicancia a nivel AFIP y el pedido debería poder eliminarse. Déjame revisar el endpoint de eliminación y las validaciones de permisos.

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\dialfa new\spisa-new\frontend\app\api\sales-orders\[id]\route.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "**/permissions*.ts" • **1** result in **1** directory</summary>

Directory: **d:\dialfa new\spisa-new\frontend** (1 file)

| File |
|------|
| `types\permissions.ts` |

</details>
</tool-use>

---

Perfecto, ahora veo el problema completo. Hay DOS lugares donde la lógica necesita ajustarse:

1. **En el endpoint PUT (edición)** - líneas 108-115: No permite editar si la factura está impresa, **sin verificar si está cancelada**
2. **La tabla del frontend ya está usando la lógica correcta** gracias al cambio que hice en el mapper

El endpoint DELETE ya maneja correctamente las facturas canceladas (línea 320-323), pero el PUT no.

Déjame ver también el endpoint de permisos:

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\dialfa new\spisa-new\frontend\app\api\sales-orders\[id]\permissions\route.ts</summary>

</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\dialfa new\spisa-new\frontend\types\permissions.ts</summary>

</details>
</tool-use>

---

Ahí está el problema. En `permissions.ts`, las líneas 29, 32, 40 y 44 verifican `invoicePrinted` **sin considerar** si la factura está cancelada. La lógica debería ser:

**"No se puede editar/borrar si la factura está impresa Y NO está cancelada"**

Necesito actualizar:
1. El archivo de permisos (permissions.ts)
2. El endpoint PUT para que use la misma lógica

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: D:\dialfa new\spisa-new\frontend\types\permissions.ts</summary>

**Chunk 1**
Lines added: 7, lines removed: 3

```diff
@@ -25,10 +25,14 @@
    status: SalesOrderStatus
  ): SalesOrderPermissions {
+   // Una factura impresa Y cancelada no debería bloquear acciones
+   // porque no tiene implicancia fiscal (solo de stock)
+   const hasActiveInvoicePrinted = status.invoicePrinted &amp;&amp; !status.invoiceCancelled;
+   
    return {
-     // No se puede editar si la factura fue impresa
-     canEdit: !status.invoicePrinted,
+     // No se puede editar si la factura fue impresa y NO está cancelada
+     canEdit: !hasActiveInvoicePrinted,
      
      // Solo se puede guardar si es editable
-     canSave: !status.invoicePrinted,
+     canSave: !hasActiveInvoicePrinted,
      
      // Solo crear factura si está guardado y no tiene factura activa
```

**Chunk 2**
Lines added: 5, lines removed: 4

```diff
@@ -37,10 +41,11 @@
        (!status.hasInvoice || status.invoiceCancelled),
      
-     // No cancelar si tiene factura impresa o si el pedido no existe aún
-     canCancel: status.id !== null &amp;&amp; !status.invoicePrinted,
+     // No cancelar si tiene factura impresa activa o si el pedido no existe aún
+     canCancel: status.id !== null &amp;&amp; !hasActiveInvoicePrinted,
      
-     // Se puede eliminar si la factura NO está impresa y el pedido ya existe
+     // Se puede eliminar si la factura NO está impresa y activa, y el pedido ya existe
      // (Cuando se imprime la factura es cuando se debita el stock)
-     canDelete: status.id !== null &amp;&amp; !status.invoicePrinted,
+     // Las facturas canceladas no bloquean porque el stock ya fue devuelto
+     canDelete: status.id !== null &amp;&amp; !hasActiveInvoicePrinted,
      
      // Crear remito si está guardado
```

</details>

</tool-use>

---

Ahora actualizo el endpoint PUT para que también considere el estado de cancelación:

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: D:\dialfa new\spisa-new\frontend\app\api\sales-orders\[id]\route.ts</summary>

**Chunk 1**
Lines added: 4, lines removed: 3

```diff
@@ -106,9 +106,10 @@
      }
  
-     // Check permissions: cannot edit if invoice is printed
+     // Check permissions: cannot edit if invoice is printed AND not cancelled
+     // Cancelled invoices don't block editing because they have no fiscal impact
      const activeInvoice = existingSalesOrder.invoices[0];
-     if (activeInvoice &amp;&amp; activeInvoice.is_printed) {
+     if (activeInvoice &amp;&amp; activeInvoice.is_printed &amp;&amp; !activeInvoice.is_cancelled) {
        return NextResponse.json(
-         { error: 'No se puede modificar un pedido con factura impresa' },
+         { error: 'No se puede modificar un pedido con factura impresa activa' },
          { status: 403 }
        );
```

</details>

</tool-use>

---

Ahora necesito agregar el campo `is_cancelled` al include del invoice en el endpoint PUT, porque actualmente no lo está trayendo:

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: D:\dialfa new\spisa-new\frontend\app\api\sales-orders\[id]\route.ts</summary>

**Chunk 1**
Lines added: 5, lines removed: undefined

```diff
@@ -92,4 +92,9 @@
        include: {
          invoices: {
+           select: {
+             id: true,
+             is_printed: true,
+             is_cancelled: true,
+           },
            where: { deleted_at: null },
            orderBy: { created_at: 'desc' },
```

</details>

</tool-use>

---

Perfecto. Ahora la lógica es consistente en todos los lugares:

## Cambios realizados:

### 1. **mapper.ts** (línea 119)
- Ahora `invoicePrinted` considera si la factura está cancelada
- Solo es `true` si hay factura NO cancelada Y está impresa

### 2. **permissions.ts** (función completa)
- Introduje la variable `hasActiveInvoicePrinted = invoicePrinted && !invoiceCancelled`
- Todas las reglas de permisos ahora usan esta variable
- Esto significa que facturas canceladas no bloquean edición/borrado

### 3. **route.ts PUT** (líneas 108-115)
- Agregué la verificación de `!activeInvoice.is_cancelled`
- Ahora solo bloquea la edición si la factura está impresa **Y** no está cancelada
- Mejoré el mensaje de error para indicar "factura impresa activa"

## Lógica de negocio implementada:

✅ **Factura impresa Y activa** → Bloquea todo (edición, cancelación, borrado)
✅ **Factura impresa pero cancelada** → NO bloquea nada (el stock ya fue devuelto, no hay implicancia AFIP)
✅ **Sin factura o factura no impresa** → Permite todo
✅ **Factura cancelada sin imprimir** → Permite todo (se elimina con soft delete)

Esto resuelve la inconsistencia que tenías. Los pedidos con facturas canceladas ahora se pueden editar y eliminar correctamente.

---

_**User (2025-12-12 10:30Z)**_

## Error Type
Console Error

## Error Message
In HTML, <div> cannot be a descendant of <p>.
This will cause a hydration error.

  ...
    <FocusScope asChild={true} loop={true} trapped={true} onMountAutoFocus={function handleEvent} ...>
      <Primitive.div tabIndex={-1} asChild={true} ref={function} ...>
        <Primitive.div.Slot tabIndex={-1} onKeyDown={function FocusScope.useCallback[handleKeyDown]} ref={function}>
          <Primitive.div.SlotClone tabIndex={-1} onKeyDown={function FocusScope.useCallback[handleKeyDown]} ...>
            <DismissableLayer role="alertdialog" id="radix-_r_3j_" aria-describedby="radix-_r_3l_" ...>
              <Primitive.div role="alertdialog" id="radix-_r_3j_" aria-describedby="radix-_r_3l_" ...>
                <div role="alertdialog" id="radix-_r_3j_" aria-describedby="radix-_r_3l_" aria-labelledby="radix-_r_3k_" ...>
                  <AlertDialogContent.Slottable>
                    <AlertDialogHeader>
                      <div data-slot="alert-dial..." className="flex flex-...">
                        <AlertDialogTitle>
                        <AlertDialogDescription>
                          <AlertDialogDescription data-slot="alert-dial..." className="text-muted...">
                            <DialogDescription __scopeDialog={{Dialog:[...]}} data-slot="alert-dial..." ...>
                              <Primitive.p id="radix-_r_3l_" data-slot="alert-dial..." className="text-muted..." ...>
>                               <p
>                                 id="radix-_r_3l_"
>                                 data-slot="alert-dialog-description"
>                                 className="text-muted-foreground text-sm"
>                                 ref={null}
>                               >
>                                 <div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded">
                    ...
                  ...
    ...



    at createConsoleError (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_b0daae9a._.js:1605:71)
    at handleConsoleError (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_b0daae9a._.js:2203:54)
    at console.error (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_b0daae9a._.js:2354:57)
    at validateDOMNesting (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:1921:372)
    at completeWork (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:6333:25)
    at runWithFiberInDEV (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:886:74)
    at completeUnitOfWork (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:8363:23)
    at performUnitOfWork (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:8300:28)
    at workLoopSync (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:8190:40)
    at renderRootSync (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:8173:13)
    at performWorkOnRoot (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:7908:212)
    at performSyncWorkOnRoot (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:8890:9)
    at flushSyncWorkAcrossRoots_impl (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:8809:316)
    at processRootScheduleInMicrotask (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:8829:106)
    at <unknown> (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_compiled_react-dom_1e674e59._.js:8901:158)
    at div (<anonymous>:null:null)
    at SingleStepOrderForm (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/_ae39e649._.js:2346:449)
    at EditSalesOrderPage (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/_ae39e649._.js:2937:229)
    at ClientPageRoot (file://D:/dialfa new/spisa-new/frontend/.next/static/chunks/node_modules_next_dist_8db7fb1f._.js:2645:50)

Next.js version: 15.5.4 (Turbopack)


---

_**Agent (model claude-4.5-sonnet-thinking, mode Agent)**_

<think><details><summary>Thought Process</summary>
Este error es claro: hay un `<div>` dentro de un `<p>`, lo cual es HTML inválido. El error está en un AlertDialogDescription que contiene un div.

El error señala específicamente:
```
<p id="radix-_r_3l_" ...>
  <div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded">
```

Esto está en el SingleStepOrderForm según el stack trace. Necesito buscar dónde hay un AlertDialog con contenido que tenga un div amarillo (bg-yellow-50).

Déjame buscar ese componente.</details></think>

---

Este es un error de hidratación de React/HTML. El problema es que hay un `<div>` dentro de un `<p>` en un `AlertDialogDescription`, lo cual no es HTML válido. El stack trace indica que está en `SingleStepOrderForm`.

Déjame buscar ese componente:

---

<tool-use data-tool-type="generic" data-tool-name="glob_file_search">
<details>
<summary>Tool use: **glob_file_search** • Searched codebase "**/SingleStepOrderForm.tsx" • **1** result in **1** directory</summary>

Directory: **d:\dialfa new\spisa-new\frontend** (1 file)

| File |
|------|
| `components\salesOrders\SingleStepOrderForm.tsx` |

</details>
</tool-use>

---

<tool-use data-tool-type="search" data-tool-name="grep">
<details>
<summary>Tool use: **grep** • Grep for "bg-yellow-50" in "D:\dialfa new\spisa-new\frontend" • 1 match</summary>

Output mode: content


| File | Content | Line |
|------|------|------|
| `.\components\salesOrders\SingleStepOrderForm.tsx` | `<div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded">` | L1112 |


</details>
</tool-use>

---

<tool-use data-tool-type="read" data-tool-name="read_file">
<details><summary>Tool use: **read_file** • Read file: D:\dialfa new\spisa-new\frontend\components\salesOrders\SingleStepOrderForm.tsx</summary>

</details>
</tool-use>

---

Encontré el problema. En las líneas 1109-1116, hay un `<div>` dentro del `AlertDialogDescription`. El componente `AlertDialogDescription` renderiza un `<p>`, y no puedes poner un `<div>` dentro de un `<p>` en HTML.

La solución es usar un `<span>` con `display: block` en lugar del `<div>`, o mover el contenido fuera del `AlertDialogDescription`:

---

<tool-use data-tool-type="write" data-tool-name="search_replace">

<details><summary>Tool use: **search_replace** • Edit file: D:\dialfa new\spisa-new\frontend\components\salesOrders\SingleStepOrderForm.tsx</summary>

**Chunk 1**
Lines added: 6, lines removed: 6

```diff
@@ -1109,10 +1109,10 @@
              &lt;AlertDialogDescription&gt;
                Esta acción eliminará el pedido permanentemente. Esta acción no se puede deshacer.
-               {existingOrder?.invoice?.isPrinted &amp;&amp; (
-                 &lt;div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded"&gt;
-                   &lt;strong&gt;Nota:&lt;/strong&gt; Este pedido tiene una factura impresa. Al eliminar el pedido, la factura será cancelada y el stock será devuelto automáticamente.
-                 &lt;/div&gt;
-               )}
-             &lt;/AlertDialogDescription&gt;
+             &lt;/AlertDialogDescription&gt;
+             {existingOrder?.invoice?.isPrinted &amp;&amp; (
+               &lt;div className="mt-2 p-2 bg-yellow-50 border border-yellow-200 rounded text-sm"&gt;
+                 &lt;strong&gt;Nota:&lt;/strong&gt; Este pedido tiene una factura impresa. Al eliminar el pedido, la factura será cancelada y el stock será devuelto automáticamente.
+               &lt;/div&gt;
+             )}
            &lt;/AlertDialogHeader&gt;
            &lt;AlertDialogFooter&gt;
```

</details>

</tool-use>

---

Perfecto. Moví el `<div>` de advertencia fuera del `AlertDialogDescription` y dentro del `AlertDialogHeader`. Ahora está al mismo nivel que el `AlertDialogDescription` en lugar de dentro de él, lo que evita el error de HTML inválido (`<div>` dentro de `<p>`).

El error de hidratación debería desaparecer ahora. La estructura queda así:

```
AlertDialogHeader
  ├─ AlertDialogTitle
  ├─ AlertDialogDescription (renderiza <p>)
  └─ div (advertencia amarilla) ✓ Válido, ya no está dentro del <p>
```

---

